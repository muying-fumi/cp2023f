<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=1900">
  <title>o12-1 理想大學環境</title>
  <style>
    html,
    body {
      margin: 0;
      overflow: hidden;
    }
  </style>
  <link rel="stylesheet" href="vendor/reveal/reset.css">
  <link rel="stylesheet" href="vendor/reveal/reveal.css">
  <link rel="stylesheet" href="vendor/reveal/theme/sky.css">

  <!-- Theme used for syntax highlighted code -->
  <link rel="stylesheet" href="vendor/reveal/plugin/highlight/zenburn.css"><!--edit-->
  <!-- Pollyfill script -->
  <script src="https://unpkg.com/core-js-bundle@3.6.1/minified.js"></script>
  <!-- Live2DCubismCore script -->
  <script src="./dist/live2dcubismcore.js"></script>
  <!-- Build script -->
  <script src="./dist/bundle.js"></script>
  <style>
    ul, ol{
      list-style: none;
      margin-left: 0;
    }
    .reveal {
      position: absolute;
      left: 0;
      top: 0;
    }

    #pageIndex{
      position: absolute;
      right: 24px;
      bottom: 24px;
      background: #000;
      color: #fff;
      font-size: 26px;
    }
    .controls{
      bottom: 24px !important;
    }
    table{
      font-size: 24px !important;
      border-style: double !important;
    }
  </style>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <!--
         data-no: 老師網頁的cubism人物編號(從0開始，網頁上的編號-1)
         data-positionx: cubism人物水平位移範圍(建議-1 ~ 0.9)
         data-positiony: cubism人物垂直位移範圍(建議-0.9~0.4)
         data-scale: cubism人物縮放(建議1~2之間的小數值，最大極限是3)
         data-motionno: cubism人物指定動作編號(從0開始，請參閱model3.json檔案的ALL MOTION GROUP)
      -->
      <section>
        <h3 style="text-align: left;">O12-1 理想大學環境</h3>
        <section data-auto-animate
          data-no="6" 
          data-positionx="0.8" 
          data-positiony="0.03" 
          data-scale="1" 
          data-motionno="0">
          <p style="font-size: 24px; text-align: left;">
            假設每一大學可以用下列 8 種屬性表示：<br>
            GF(Good Food) ：代表附近有美食。<br>
            BC(Big Campus)：代表有大校園。<br>
            NC(Next to City)：代表鄰近有大城市。<br>
            CT(Convenient Transportation)：代表交通方便。<br>
            NS(Next to Sea)：代表靠海。<br>
            NM(Next to Mountain)：代表依山。<br>
            HL(Has Lake)：代表校園有湖。<br>
            NL(Near Landscape)：代表附近有風景區。<br>
          </p>
        </section>
        <section data-auto-animate
          data-no="6" 
          data-positionx="0.8" 
          data-positiony="0.03" 
          data-scale="1" 
          data-motionno="0">
          <p style="font-size: 24px; text-align: left; font-weight: bold;">
            輸入說明：</p>
          <p style="font-size: 24px; text-align: left;">
            1. 第一行輸入一個正整數 n，代表大學個數 n ，(n&lt;=10)。<br>
            2. 其後 n 行，每一行第一項為大學名稱，接著為其屬性。大學名稱最多有 10 個字母，各屬性為 2 個字母。大學與屬性資料均為英文字母組成，大學名稱及各屬性間以 1 個空白分隔。<br>
            3. 接下來 1 行輸入一個正整數 m，為查詢個數，(m&lt;=10)。<br>
            4. 其後 m 行，每一行有一個查詢。查詢條件為校園屬性組成，每個校園屬性為 2 個字元。用 + 號區格的條件代表"或" 的關係，沒有 + 區隔的條件代表 "且" 的關係。屬性間及 + 之間有 1 個空白間隔。例如： BC NS + CT HL 代表需找出【大校園且靠海】，或【交通方便且校園有湖】的所有大學名稱。其格式如下:<br>
                XX YY + AA BB<br> 
                意思為屬性條件為: XX 且 YY，或是 AA 且 BB。<br>
            5. 最後 1 行輸入一個正整數 b，b=0，代表輸出能符合條件的大學。例如：條件 NS BC NC + CT HL，大學屬性NTUT NC BC NS ，則 NTUT 符合條件。 b=1，代表輸出部分符合且符合最多條件的大學。例如：條件 NS BC NC + CT HL，大學屬性 NTUT BC NS、 NTUST BC，則輸出 NTUT。
          </p>
        </section>
        <section data-auto-animate
          data-no="6" 
          data-positionx="0.8" 
          data-positiony="0.03" 
          data-scale="1" 
          data-motionno="0">
          <p style="font-size: 24px; text-align: left; font-weight: bold;">
            輸出說明：</p>
          <p style="font-size: 24px; text-align: left;">
            m 行，第 i 列印出第 i 個查詢中，所有符合之大學名稱。<br>
            若有多個大學符合一個查詢，各大學間以一個空白分隔。<br>
            每行查詢的輸出順序，根據先後子查詢條件符合的大學順序輸出。<br> 
          </p>
        </section>
      </section>
      <section>
        <h3>Input/Output</h3>
        <section data-auto-animate
        data-no="6" 
        data-positionx="0.8" 
        data-positiony="0.03" 
        data-scale="1" 
        data-motionno="0">
          <img src="img/ch9/006.png">
        </section>        
        <section data-auto-animate
        data-no="6" 
        data-positionx="0.8" 
        data-positiony="0.03" 
        data-scale="1" 
        data-motionno="0">
          <img src="img/ch9/007.png">
        </section> 
        <section data-auto-animate
        data-no="6" 
        data-positionx="0.8" 
        data-positiony="0.03" 
        data-scale="1" 
        data-motionno="0">
          <img src="img/ch9/008.png">
        </section> 
        <section data-auto-animate
        data-no="6" 
        data-positionx="0.8" 
        data-positiony="0.03" 
        data-scale="1" 
        data-motionno="0">
          <img src="img/ch9/009.png">
        </section> 
    </section>
    <section>
      <h3>hints</h3>
      <section data-auto-animate
        data-no="17" 
        data-positionx="0.8" 
        data-positiony="0.03" 
        data-scale="1" 
        data-motionno="0">
        <font size=5>移位運算子：&lt;&lt; 和 &gt;&gt;</font>
        <pre><code data-trim data-noescape>
          舉例：有一個數a = 0000 0110 (二進制)
          則
            a &lt;&lt; 1 = 0000 1100  //1為10進制，最低位補0
            a &gt;&gt; 1 = 0000 0011  //1為10進制，最高位補0
          而 a &gt;&gt; 2 相當於 a &gt;&gt; 1 做兩次
          可知 a &gt;&gt; 2 = 0000 0011 &gt;&gt; 1 = 0000 0001
          同理，假設是 1000 0000 &lt;&lt; 1 則會得到 0000 0000

          我們可以用1 &lt;&lt; n得到等價於2的n次方的結果。
        </code></pre> 
      </section>       
      <section data-auto-animate
        data-no="17" 
        data-positionx="0.8" 
        data-positiony="0.03" 
        data-scale="1" 
        data-motionno="0">
        <font size=5>bitwise or</font>
        <pre><code data-trim data-noescape>
          or的規則為：
            0 or 0得0
            0 or 1得1
            1 or 0得1
            1 or 1得1
          舉例：有一個數a = 0000 0001 (2進制)
          or以|表示
          則
            a | 1 = 0000 0001   //1(10進制) = 0000 0001(2進制)
            a | 2 = 0000 0011   //2(10進制) = 0000 0010(2進制)  
            a | 4 = 0000 0101   //4(10進制) = 0000 0100(2進制)  
            a | 8 = 0000 1001   //8(10進制) = 0000 1000(2進制)  
          依此類推
        </code></pre> 
      </section>
      <section data-auto-animate
        data-no="17" 
        data-positionx="0.8" 
        data-positiony="0.03" 
        data-scale="1" 
        data-motionno="0">
        <font size=5>bitwise and</font>
        <pre><code data-trim data-noescape>
          and的規則為：
            0 and 0得0
            0 and 1得0
            1 and 0得0
            1 and 1得1
          舉例：有一個數a = 0000 0110 (2進制)
          and以&表示
          則
            a & 1 = 0000 0000   //1(10進制) = 0000 0001(2進制)
            a & 2 = 0000 0010   //2(10進制) = 0000 0010(2進制) 
            a & 4 = 0000 0100   //4(10進制) = 0000 0100(2進制) 
            a & 8 = 0000 0000   //8(10進制) = 0000 1000(2進制) 
          依此類推
        </code></pre> 
      </section>
      <section data-auto-animate
        data-no="17" 
        data-positionx="0.8" 
        data-positiony="0.03" 
        data-scale="1" 
        data-motionno="0">
        <font size=5>|= 和 &=</font>
        <pre><code data-trim data-noescape>
          將bitwise or和bitwise and應用在assignment
          舉例：有一個數a = 0000 0101 (2進制)
          假想有以下程式片段：
            a |= 1;  //a = 0000 0101
            a |= 2;  //a = 0000 0111
            a &= 4;  //a = 0000 0100
            printf("a=%d",a); //會印出a=4

          寫程式的時候使用的是10進制數字，思考時可將10進制轉為2進制
          例如在做 a |= 2; 時，可以看作 0000 0101 | 0000 0010
          則兩者or起來的結果即為 0000 0111
          將這個結果assign給a才算做完a |= 2;這個敘述
        </code></pre> 
      </section>
      <section data-auto-animate
        data-no="17" 
        data-positionx="0.8" 
        data-positiony="0.03" 
        data-scale="1" 
        data-motionno="0">
        <font size=5>移位運算子和bitwise and/or的應用</font>
        <pre><code data-trim data-noescape>
          舉例：有一個數a = 0000 1010 (2進制)
          假想有以下程式片段：
            a |= 1 &lt;&lt; 0;  //a | 0000 0001 ; a = 0000 1011
            a &= 2 &lt;&lt; 2;  //a & 0000 1000 ; a = 0000 1000
            a |= 4 &gt;&gt; 2;  //a | 0000 0001 ; a = 0000 1001
            printf("a=%d",a);   //會印出a=9

          在做以上運算時，先將等號右方的數值以二進制算好，
          再把算好的值跟a做and/or，
          最後把結果assign給a。
        </code></pre> 
      </section>
    </section>
    <section>
      <h3>解答</h3>
      <section data-auto-animate
        data-no="8" 
        data-positionx="0.8" 
        data-positiony="0.03" 
        data-scale="1" 
        data-motionno="0">
        <font size=5>標頭檔 & 常數 & 結構定義</font>
        <pre><code data-trim data-noescape data-line-numbers>
          #include &lt;stdio.h&gt;
          #include &lt;string.h&gt;
          
          #define	PROP_CNT	8
          #define	MAX_UNIVERSITY	10
          
          typedef struct u {
            char name[11];	//名稱(最多10字母)
            int props;		//屬性(透過8個bit來表示8種屬性是否擁有)
            int match_cnt;	//符合次數(根據mode不同定義不同)
          } University;
          
          typedef struct q {
            int flags[9]; //每組or條件用一個int表示，最多9組
            int cnt;			//實際有幾組or條件
          } Query;
        </code></pre> 
      </section>
    </section>
    <section>
      <h3>解答</h3>
      <section data-auto-animate
        data-no="8" 
        data-positionx="0.8" 
        data-positiony="0.03" 
        data-scale="1" 
        data-motionno="0">
        <font size=5>副程式_取得屬性索引值</font>
        <pre><code data-trim data-noescape data-line-numbers>
          int getPropIdx(char* name) {  //-1 or 0 to PROP_CNT-1
            const char prop_names[PROP_CNT][2]={"GF","BC","NC","CT","NS","NM","HL","NL"};
            for (int idx=0; idx&lt;PROP_CNT; idx++)
              if (name[0]==prop_names[idx][0] && name[1]==prop_names[idx][1])
                return idx;	//找到該屬性，回傳該屬性對應索引值
            return -1;	//找不到該屬性
          }
        </code></pre> 
      </section>       
    </section>
    <section>
      <h3>解答</h3>
      <section data-auto-animate
        data-no="8" 
        data-positionx="0.8" 
        data-positiony="0.03" 
        data-scale="1" 
        data-motionno="0">
        <font size=5>副程式_取得符合屬性數</font>
        <pre><code data-trim data-noescape data-line-numbers>
          int matchPropCnt(int flags) {   //每符合一個屬性則加1
            int rtn=0, mask=1;
            for (int i=0; i&lt;PROP_CNT; i++) {
              if (flags & mask)
                rtn++;
              mask=mask &lt;&lt; 1;
            }
            return rtn;
          }
        </code></pre> 
      </section>       
    </section>
    <section>
      <h3>解答</h3>
      <section data-auto-animate
        data-no="8" 
        data-positionx="0.8" 
        data-positiony="0.03" 
        data-scale="1" 
        data-motionno="0">
        <font size=5>副程式_根據查詢條件輸出對應學校</font>
        <pre><code data-trim data-noescape data-line-numbers="1-6|8-27|28-36">
          //mode=0要全部符合, mode=1時部分符合即可
          void match(University *u_ptr, int u_cnt, Query *q_ptr, int mode) {
            int i, j, best_cnt=0, m_flags;
          
            for(i=0; i&lt;u_cnt; i++) //初始化每個大學的符合條件數
              u_ptr[i].match_cnt=0;//在mode不同時，符合條件數的定義稍有不同
          
            for (j=0; j&lt;q_ptr->cnt; j++) {	//針對每一組or條件判斷屬性符合數
              int q_flags=q_ptr->flags[j];  //一組or條件(例如GF BC+NC為兩組or條件)
              for (i=0; i&lt;u_cnt; i++) {
                m_flags=u_ptr[i].props & q_flags;	//該大學屬性和一組or條件相同的部分
                if (m_flags!=0) {  //!=0表示至少有一屬性符合
                  if(mode==0) {
                    if (m_flags==q_flags) {   //所有bit(屬性)均符合
                      if (u_ptr[i].match_cnt==0)
                        printf("%s ", u_ptr[i].name);
                      u_ptr[i].match_cnt=1;	//match_cnt用來判斷是否印過該大學
                    }
                  }
                  else {  //mode=1，需紀錄目前最大符合數
                    u_ptr[i].match_cnt+=matchPropCnt(m_flags);
                    if (best_cnt&lt;u_ptr[i].match_cnt)	
                      best_cnt=u_ptr[i].match_cnt;	//更新最大符合數
                  }
                }
              }
            }
            if (mode==1) {   //印出符合屬性數最多的學校(可能多個)
              for (i=0; i&lt;u_cnt; i++) {
                if (u_ptr[i].match_cnt==best_cnt)
                  printf("%s ", u_ptr[i].name);
              }
            }
            //已根據該查詢條件輸出大學，若有下一個查詢條件，則換行繼續輸出
            printf("\n"); 
          }
        </code></pre> 
      </section>       
    </section>
    <section>
      <h3>解答</h3>
      <section data-auto-animate
        data-no="8" 
        data-positionx="0.8" 
        data-positiony="0.03" 
        data-scale="1" 
        data-motionno="0">
        <font size=5>主程式</font>
        <pre><code data-trim data-noescape data-line-numbers="1-5|7-21|23-40|42-50">
          int main() {
            int i, M, N, mode, idx;
            char buf[256], *p;
            University universities[MAX_UNIVERSITY];
            Query queries[10];   //最多10個query(By題目)
          
            scanf("%d\n",&N);	//有N所大學
            for (i=0; i&lt;N; i++) {
              gets(buf);
              p=strtok(buf, " ");
              strcpy(universities[i].name,p);
              universities[i].props=0; //初始化該大學擁有的屬性
          
              p=strtok(NULL, " ");
              while(p!=NULL) {
                idx=getPropIdx(p);
                if (idx>=0)  //合法屬性
                  universities[i].props |= (1 &lt;&lt; idx);
                p=strtok(NULL, " ");
              }
            }
          
            memset(queries, 0, sizeof(queries));//初始化query的所有內容
            scanf("%d\n", &M);  //有M筆查詢
            for (int i=0; i&lt;M; i++) {
              gets(buf);
              p=strtok(buf, " ");
              while (p != NULL) {
                if (*p=='+')
                  queries[i].cnt++; //結算至加號前一個屬性
                else {	//p指向的內容為屬性
                  idx=getPropIdx(p);
                  if (idx>=0) {	//合法屬性
                    queries[i].flags[queries[i].cnt] |= (1 &lt;&lt; idx);
                  }
                }
                p = strtok(NULL, " ");
              }
              queries[i].cnt++; //加上最後一個屬性
            }
          
            scanf("%d", &mode);
            //輸出符合情況：
            //mode=0時輸出全部符合的有哪些學校；
            //mode=1時輸出部分符合中符合最多的學校
            for (int i=0; i&lt;M; i++) 
              match(universities, N, &queries[i], mode);
          
            return 0;
          }
        </code></pre> 
      </section>       
    </section>
    </div>
  </div>
  <div id="pageIndex"></div>
  <!-- reveal.js-->
  <script src="vendor/reveal/reveal.js"></script>
  <!--plugin-->
  <script src="vendor/reveal/plugin/math/math.js"></script>
  <script src="vendor/reveal/plugin/search/search.js"></script>
  <script src="vendor/reveal/plugin/zoom/zoom.js"></script>

  <script src="vendor/reveal/plugin/notes/notes.js"></script>
  <script src="vendor/reveal/plugin/markdown/markdown.js"></script>
  <script src="vendor/reveal/plugin/highlight/highlight.js"></script>
  <script src="main-ppt.js"></script>
</body>

</html>
